### Check for Commonly Used Application and Administrative URLs

To identify commonly used application and administrative URLs, you can use OWASP ZAP’s **Active Scan** feature with a predefined wordlist of common URLs. Set up your target URL in ZAP and then configure the scan to include paths like `/admin`, `/login`, and `/dashboard`. This will help you discover any accessible administrative paths that might not be properly secured.

### Check for Old, Backup, and Unreferenced Files

In OWASP ZAP, you can use the **Spider** function to crawl the application and check for unlinked files. Configure the Spider to scan for file extensions such as `*.bak`, `*.old`, and `*.sql`. Additionally, you can use the **Fuzzer** feature in ZAP to test specific endpoints for these file types by creating a custom payload list that includes these extensions.

### Check HTTP Methods Supported and Cross-Site Tracing (XST)

To check the supported HTTP methods in OWASP ZAP, you can send an **OPTIONS** request to your target URL. Right-click on the target in the ZAP interface and select "Attack" -> "Active Scan," ensuring you include the method options in the scan configuration. To test for Cross-Site Tracing (XST), manually create a **TRACE** request using the request editor in ZAP, where you can modify the HTTP method to TRACE and observe the response.

### Test File Extensions Handling

Use OWASP ZAP to test how the application handles various file extensions. You can modify requests using the **Request Editor** to append different extensions like `.php`, `.txt`, or `.pdf` to the URLs. Monitor the responses in the ZAP interface to check for any inconsistencies in how the server processes these extensions. This helps identify if there are vulnerabilities such as execution of unintended code.

### Test for Security HTTP Headers

To check for important security HTTP headers in OWASP ZAP, use the **Request Editor** to send a request to the target URL. Analyze the HTTP response headers in the ZAP interface for headers like **Content-Security-Policy**, **X-Frame-Options**, **Strict-Transport-Security**, **X-Content-Type-Options**, and **X-XSS-Protection**. This will allow you to verify if the application has implemented these security features.

**Important Headers**: Check for the following headers:

- **CSP (Content Security Policy)**
	- Content Security Policy (CSP) is a security feature that helps prevent Cross-Site Scripting (XSS) and other code injection attacks by allowing web developers to specify which sources of content are considered trusted. By defining rules in the HTTP header, such as where scripts, images, and styles can be loaded from, CSP reduces the risk of malicious content being executed in a web page, thereby enhancing overall security.
- **X-Frame-Options**
	- X-Frame-Options is a security header that protects websites from clickjacking attacks by controlling whether a web page can be embedded within a frame, iframe, or object. It can be set to three values: `DENY` (no rendering in a frame), `SAMEORIGIN` (can be framed only by pages from the same origin), or `ALLOW-FROM uri` (can be framed only by specified origins). This header helps ensure that users are not tricked into interacting with malicious content.
- **HSTS (HTTP Strict Transport Security)**
	￼￼C- HTTP Strict Transport Security (HSTS) is a web security policy mechanism that enforces secure (HTTPS) connections to a web server, preventing man-in-the-middle attacks and protocol downgrades. When a server responds with the HSTS header, compliant browsers will automatically redirect any requests to the server to HTTPS for a specified duration, ensuring that all communication remains encrypted and secure.
- **X-Content-Type-Options**
	- X-Content-Type-Options is a security header that prevents browsers from MIME-sniffing the content type of a response away from the declared `Content-Type`. By setting this header to `nosniff`, web developers can ensure that browsers strictly adhere to the specified content type and do not treat files as a different type than intended, mitigating risks associated with improperly handled content.
- **X-XSS-Protection**
	- X-XSS-Protection is a security header used to enable the built-in cross-site scripting (XSS) filter in modern web browsers. When set to `1; mode=block`, it activates the filter and instructs the browser to block the page from rendering if an XSS attack is detected, rather than attempting to sanitize the response. This provides an additional layer of defense against XSS vulnerabilities in web applications.

#### Well configured headers example
```bash
HTTP/1.1 200 OK
Date: Sun, 24 Sep 2024 12:00:00 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html; charset=UTF-8
Content-Security-Policy: default-src 'self'; script-src 'self' https://trustedscripts.com
X-Frame-Options: SAMEORIGIN
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
```


### Test for Policies (e.g., Flash, Silverlight, robots)

In ZAP, you can check for the presence of Flash and Silverlight files by spidering the application to uncover any `.swf` or `.xap` files. You can also manually navigate to `http://example.com/robots.txt` in your browser or use ZAP to access this file directly. Reviewing this file will help you understand what paths are disallowed for web crawlers and could reveal sensitive information.

### Test for Non-production Data in Live Environment, and Vice-versa

Using OWASP ZAP, conduct a thorough scan of the application to identify any non-production data that should not exist in a live environment. Pay attention to configurations, test data, or deprecated files that appear during your active scans. Manual review through the ZAP interface can help you spot any suspicious non-production data.

### Check for Sensitive Data in Client-Side Code

To check for sensitive data in client-side code using ZAP, analyze the captured requests and responses from your spidering or active scanning sessions. Inspect the JavaScript files and HTML source code loaded in the browser through ZAP's **Sites** tab to look for hardcoded API keys or credentials. Use ZAP's **Static Analysis** feature if available to search for hardcoded secrets within the scanned resources.